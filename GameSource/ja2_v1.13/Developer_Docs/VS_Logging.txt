*** Howto use CLog class ***

Using the CLog class is like using std::cout, but since there is no text console, 
cout doesn't work. Instead CLog writes its entries to a file.

There are two ways to create a CLog object:

1. Temporary log

  CLog(vfs::Path const& fileName, bool append = false, EFlushMode flushMode = FLUSH_ON_DELETE);
  
  e.g.
  CLog log_object(L"log.log");
  CLog log_object(L"another.log", false, FLUSH_IMMEDIATELY);

When 'append' is set to false, the file 'fileName' is rewritten every time.
When 'append' is true, then the log entries are put at the end of the given file. 

'flushMode' determines when the log is actually written to disc. 
- FLUSH_ON_DELETE   : write when log object is deleted = e.g. leaves scope. 
- FLUSH_BUFFER      : write when internal buffer if full (512 bytes). 
- FLUSH_IMMEDIATELY : every entry is written immediately. 

Using FLUSH_IMMEDIATELY is useful when there is a crash and you can't wait for 
a flush to occur somewhere in the future. 


2. Persistent log

  static CLog* CLog::create(vfs::Path const& fileName,
                            bool append = false,
                            EFlushMode flushMode = FLUSH_ON_DELETE);

  e.g.
  static CLog& log_object = *CLog::create(L"persistent.log", true, FLUSH_BUFFER);

The comments from case 1. also apply here.

If you want to log a specific event, use the temporary log approach.

If you want to log events that can occur during the whole lifetime of 
the program, use the persistent log approach.
  
The persistent log approach uses a reference to an object that is handled by 
the CLog class, especially its destruction.


The CLog class overrides the operator<<, so that the log object can be used in 
a similar way to the std::cout object.

  e.g.
  {
    CLog log(L"test.log);
	log << "start log" << CLog::ENDL;
	log << "entry : " << 10 << CLog::ENDL;
  } // leaving scope -> writing to file
  